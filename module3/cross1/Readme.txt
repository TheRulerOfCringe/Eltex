У клиента порт любой, а ip либо 127._._._, либо 10.0.2.15 (адрес машины, hostname -I)
У сервера порта фиксированного нет, при отправке берём порт из src в сообщении клиента, на принятие не bind'им, мы ж raw.
то есть

клиент1 -> сервер
UDP: src_port= X1 , dest_port= Y1

сервер -> клиент1
UDP: src_port= Y1 , dest_port= X1

клиент2 -> сервер
UDP: src_port= X2 , dest_port= Y2

сервер -> клиент2
UDP: src_port= Y2 , dest_port= X2

Даже если Y1 = Y2, то всё окей.

У клиента будет addr.sin_port = 0, чтобы всегда была уникальная пара ip:port.
Что гарантирует X1 != X2 при одинаковом ip.

Чтобы понять, что это пакет нам, мы добавляем в начале секретный тэг - пока что это 2082003. Без него мы на вообще все пакеты будем отсылать echo, а не только на запросы клиента

Если ip и порт пакета совпадают с ip и портом взаимодействия с сервером одного из клиентов (даже удалённых, но это временно), то это наш же пакет, мы его игнорируем.

Выход сделан корректно, если сервер вырубается по ^C, то клиентам об этом будет передан пакет, они автоматически закроются. Если у клиента прописать "exit" или нажать ^C, то серверу придёт пакет с exit, чтобы он вычеркнул этого клиента из массива клиентов.

То есть взаимодействие происходит так:

Клиент кидает "секретный код" + " " + "своё сообщение".
Сервер парсит пакет, отделяет секретный код от сообщения, проверяет код, если он совпадает с нашим, то проверяем, был ли такой клиент раньше. Если не был - записываем, если нет места - просто дропаем сообщение без ответа какого-либо. Потом отсылаем "сообщение" + " " + "номер сообщения". Теперь уже без секретного кода, клиент не raw, он только наши принимает.

Пример запуска на моей машине:
./client 10.0.2.15 55555
./client 10.0.2.15 55556
./server

На данном этипе каждую секунду принтим количество принятых (даже своих же) пакетов. Просто смотрел, что сервер жив.
